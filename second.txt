 /// <summary>
            /// Processes the loaded pixels.
            /// </summary>
            /// <param name="pixelsRectangle">The pixels rectangle.</param>
            /// <param name="pixels">The pixels.</param>
            /// <param name="start">The start pixels point. If not equal to (left,top) meaning that it is not full rectangle we have.</param>
            /// <param name="end">The end pixels point. If not equal to (right,bottom) meaning that it is not full rectangle we have.</param>
            public void Process(Rectangle pixelsRectangle, int[] pixels, Point start, Point end)
            {
                bool applyMemoryOptimization = this.byteArrayPool != null;

                if (applyMemoryOptimization)
                {
                    // for memory optimization strategy
                    this.buffer = this.byteArrayPool.GetArray(pixelsRectangle.Width * pixelsRectangle.Height);
                    this.bufferOffset = 0;
                }

                IColorPalette palette = applyMemoryOptimization ? this.colorPalette : this.paletteHash;

                // local cache to improve performance
                byte[] buffer = this.buffer;

                int bufferOffset = this.bufferOffset;
                int bufferLength = Math.Min(buffer.Length - bufferOffset, pixels.Length);
                int index = 0;

                GifFrameBlock block = this.frame as GifFrameBlock;
                bool hasTransparentColor = block != null && block.ControlBlock != null && block.ControlBlock.HasTransparentColor;
                byte transparentFromPalette = hasTransparentColor ? (byte)palette.GetNearestColorIndex(block.TransparentColor) : byte.MinValue;

                Multithreading.IInterruptMonitor monitor = Multithreading.InterruptMonitor.ThreadLocalInstance;

                do
                {
                    for (int i = 0; i < bufferLength; i++)
                    {
                        if (monitor != null && monitor.IsInterrupted)
                        {
                            throw new OperationInterruptedException("The operation has been interrupted.");
                        }

                        // now it is very optimized by using hashed color values.
                        // if GIF contains similar pixels then previously calculated color value is used.
                        // according to tests the speeed is now more than 5 times faster than before. 
                        int pixel = pixels[index++];

                        buffer[bufferOffset++] = 
                            (hasTransparentColor && pixel == 0) ? transparentFromPalette : (byte)palette.GetNearestColorIndex(pixel);
                    }

                    if (buffer.Length - bufferOffset == 0)
                    {
                        // encode when buffer is full.
                        this.encoder.Encode(buffer, bufferOffset);
                        bufferOffset = 0;
                    }

                    bufferLength = Math.Min(buffer.Length - bufferOffset, pixels.Length - index);
                }
                while (bufferLength > 0);

                // update class fields from local cache
                this.bufferOffset = bufferOffset;

                this.expectedPixels -= pixels.Length;

                if (this.expectedPixels == 0)
                {
                    // encode the last data.
                    this.FlashData(false);
                }
                else if (applyMemoryOptimization)
                {
                    // for memory optimization strategy
                    this.encoder.Encode(this.buffer, this.bufferOffset);
                }
            }